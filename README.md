# JWT
# Cookie 인증 
Cooke란 'key-value' 형식의 문자열 덩어리
클라이언트가 어떠한 웹사이트 방문할 때, 사용하고 있는 브라우저에 설치되는 작은 기록 정보파일

 1. -> 브라우저 요청
 2. <- 응답시 헤더에 cookie값 첨부
 3. -> 이후 클라이언트 요청시 마다 쿠키를 헤더에 첨부하여 보냄
 	   서버는 쿠키 바탕으로 클라이언트 식별 

 ## Cookie 방식의 단점 
 1. 가장 큰 단점은 보안에 취약 
 	요청시 쿠키값 보내기 때문에 유출 및 조작 가능 
 2. 쿠기에 용량 제한 있어 많은 정보 담을 수 없음
 3. 웹 브라우저마다 쿠키에 대한 지원 형태 달라 브라우저간 공유 불가 
 4. 쿠키 사이즈 커질수록 네트워크 부하 심해짐 


# Session 인증
Cookie의 보안적 이슈때문에, 세션의 경우 비번 등 민감한 정보를 서버측에 저장하고 관리 함
서버의 메모리에 저장하고 하고, 서버의 로컬파일이나 데이터베이스 저장하기도 함
아에 민감한 정보를 클라이언트에 보내지 않고 서버에 모두 관리함 
1. -> 유저가 웹사이트 로그인하면 서버메모리에 저장됨
2.  서버에서 브라우저에 쿠키에다가 Session id 저장
3. -> 쿠키에 정보가 담겨있기 때문에 브라우저는 해당 사이트에 모든 Request에 Session id 쿠키에 담아 전송
4. 서버는 클라이언트가 보낸 Session id 와 서버 메모리로 관리하고 Session id비교하여 인증함 

## Session 방식의 단점 
1. 쿠키를 포함한 요청이 외부에 노출되더라도 Session자체는 개인정보를 담고 있지는 않음 
   Session 탈취시 클라이언트로 위장 가능 
2. 서버에서 세션 저장소 사용함으로 요청이 많아지면 서버에 부하가 됨 


# Token 인증
서버에 접속시 클라이언트에게 인증의 의미로 토큰을 부여함
토큰은 유일하며 클라이언트는 또 다시 서버에 요청을 보낼 때 요청해더에 토큰을 심어 보냄 
서버는 클라이언트에게 받은 토큰을 서버에 제공한 토큰과 일치 여부 체크하여 인증처리함 

세션과 다른점이라면 세션은 파일이나 데이터베이스에 세션정보를 가지고 있어 조회를 해야하는데 많은 오버헤드가 발생한
반면 토큰은 세션과 달리 서버가 아닌 클라이언트에 저장이 되기 때문에 서버에 무리가 덜하다
토큰이 위변조 되었는지만 확인하면 되기 때문이다. 

1. 사용자가 로그인
2. 서버에서 클라이언트에게 토큰발급
3. 서버측에서 전달 받은 토큰을 쿠키나 스토리지에 저장해두고, 서버가 요청시마다 해당토큰을 Request 헤더에 포함하여 전달.
4. 서버는 전달받은 토큰을 검증하고 응답함.
   토큰에는 인적정보 담겨 있기때문에 DB조회 하지 않고는 누가 요청하는지 알 수 없음

 ## Token 방식의 단점 
 1. 쿠키/세션과 다르게 토큰 자체의 데이터 길이가 길어, 인증 요청시 네트워크 부하가 심해질 수 있음
 2. Payload 자체는 암호화 되지 않기 때문에 중요한 정보 담을 수 없다.
 3. 토큰을 탈취당하면 대처하기 어려움 


 # JSON WEB TOKEN
 인증에 필요한 정보들을 암호화시킨 JSON 토큰이다
 JWT 기반 인증은 JWT 토큰(Access Token)을 HTTP헤더에 실어 서버가 클라이언트를 식별하는 방식
 JWT는 JSON 데이터를 Base64 URL-safe Encode 를 통해 인코딩하여 직렬화한 것이며, 토큰 내부에는 위변조 방지를 위해 개인키를 통한 전자서명도 들어있다.
   *Base64 URL-safe Encode 는 일반적인 Base64 Encode 에서 URL 에서 오류없이 사용하도록 '+', '/' 를 각각 '-', '_' 로 표현한 것*


 ## JWT 구조 
///////////////////////

eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6InJpc3RyZXR0byIsImlhdCI6MTUxNjIzOTAyMn0.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
//////////////////////


 	JWT는 . 을 구분자로 나누어지는 세 가지 문자열의 조합이다.
    . 을 기준으로 좌측부터 Header, Payload, Signature를 의미한다.
	Header 에는 JWT 에서 사용할 타입과 해시 알고리즘의 종류가 담겨있다.
	Payload 는 서버에서 첨부한 사용자 권한 정보와 데이터가 담겨있다. 
	Signature 에는 Header, Payload 를 Base64 URL-safe Encode 를 한 이후 Header 에 명시된 해시함수를 적용하고, 개인키(Private Key)로 서명한 전자서명이 담겨있다.

	전자서명에는 비대칭 암호화 알고리즘을 사용하므로 암호화를 위한 키와 복호화를 위한 키가 다르다. 암호화(전자서명)에는 개인키를, 복호화(검증)에는 공개키를 사용한다.

## Header
{
  "alg": "HS256",
  "typ": "JWT"
}
alg :서명 암호화 알고리즘
typ :토큰 유형

## Payload
{
  "sub": "1234567890",   //제목
  "name": "ristretto",  //이름
  "iat": 1516239022     //발행시간
}
토큰에서 사용할 정보의 조각들인 Claim 이 담겨있다. (실제 JWT 를 통해서 알 수 있는 데이터) *key-value 형식으로 이루어진 한쌍의 정보를 Claim이라함*
즉, 서버와 클라이언트가 주고받는 시스템에서 실제로 사용될 정보에 대한 내용을 담고 있는 섹션이다.

## Signature
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  
your-256-bit-secret

)
시그니처에서 사용하는 알고리즘은 헤더에서 정의한 알고리즘 방식(alg)을 활용한다.
시그니처의 구조는 (헤더 + 페이로드)와 서버가 갖고 있는 유일한 key 값을 합친 것을 헤더에서 정의한 알고리즘으로 암호화를 한다.


# JWT 이용한 인증 과정
1. -> 사용자 로그인 인증요청
2. <- 서버에서 인증시 header, payload, signature 정의 후 base 64로 함호화 하여 JWT생성하고 이를 쿠키에 담아 클라이이언트에 발급
3. -> 클라이언트는 서버로부터 받은 JWT 로컬 스토리지에 저장.
   API요청 時 Authorization header에 Access Token을 담아 보냄

4. <- 서버는 토큰일치 여부 확인 후 페이로드에 있는 정보 클라이언트에 보내줌
5. -> 클라이언트가 서버에 요청시 엑세스 토큰 시간 만료시 리프래시 토큰이용해 새로운 토큰 받을 수 있음

## 토큰 인증 신뢰성을 가지는 이유
JWT를 : A(header)+ B(payload) + C(Signature) 구조로 본다면 
1. 해커가 B를 임의로 수정 -> 유저 JWT: A + B' + C
2. 수정한 토큰을 서버에 요청을 보내면 서버는 유효성 검사 시행
	해커: JWT: A + B' + C
	서버에서 검증 후 생성한 JWT: A + B' + C' => (signature) 불일치
3. 대조 결과가 일치하지 않아 유저의 정보가 임의로 조작되었음을 알 수 있다.

JWT를 사용하는 이유에는 토큰 內에 정보를 알아낸는것이 아닌 유효 유무확인 하는것이 중요하기에 서버에서 시그니처 값 다시 생성후 비교해 일치 유무 확인함

## JWT 장단점 정리 
장점
1. Header와 Payload를 가지고 Signature를 생성하므로 데이터 위변조를 막을 수 있다.
2. 인증 정보에 대한 별도의 저장소가 필요없다.
3. JWT는 토큰에 대한 기본 정보와 전달할 정보 및 토큰이 검증됬음을 증명하는 서명(시그니처) 등 필요한 모든 정보를 자체적으로 지니고 있다.
4. 클라이언트 인증 정보를 저장하는 세션과 다르게, 서버는 무상태(StateLess)가 되어 서버 확장성이 우수해질 수 있다.
5. 토큰 기반으로 다른 로그인 시스템에 접근 및 권한 공유가 가능하다. (쿠키와 차이)
6. OAuth의 경우 Facebook, Google 등 소셜 계정을 이용하여 다른 웹서비스에서도 로그인을 할 수 있다.
7. 모바일 어플리케이션 환경에서도 잘 동작한다. (모바일은 세션 사용 불가능)

단점
1. self-contained 토큰 자체에 정보에 정보를 담고있어
2. 토큰길이가 늘어면 네트워크 부하생길수 있다
3. payload는 base64인코딩이라 중요정보 넣을 수 없다.
4. 서버가 무상태이기 때문에 클라이언트 측에서 토큰 관리한다 



# JWT 공격 방법

## None Algorithm attack
JWT 헤더 생성시 alg 값을 None으로 명시했거나, 일부 JWT 라이브러리들은 alg 값에 none 등 비서명 처리 시 서명검증을 하지 않고 넘어갈 수 있는 취약성을 가지고 있다.
none으로 되어있으면 시그니처가 비어있어도 모든 토큰이 유호한것으로 간주됨

## HMAC Algorithm
HMAC 알고리즘 사용시 동일키로 서명 되어 rsa 암호로 구현되어있어도 hmac암호화로 명시시 공개키로 암호화함 

## 토큰 하이재킹
토큰 전송과정에서 공격자에 의해서 토큰이 가로채기 및 도난 당한 경우 서버는 아무것도 해줄수 없다.
  -이러한것을 줄이기위해서 httponly, secure 쿠키, samesite등 http헤더 플래그를 사한다.

## Bruteforce the secret key
결국 JWT는 base64인코딩되어있음으로 키를 무차별 대입을 통해 공격이 가능하다 

## KID manipulation
KID =key id
KID는 키 파일 검색시에 사용되어 삭제되지 않을 경우 디렉토리 리스닝으로 이어질수 있음 
"KID": "../../../public/joo/jwt.md"
위와 같은 형식으로되어있기 때문에 위험함
또한 SQL injection도 발생할수 있는데 데이터베이스에서 키를 검색할수도 있기때문에 이를 이용해서 JWT 서명 우회가 가능하다. 
“kid”: "aaaaaaa' UNION SELECT 'key';--" 여기서 key를 토큰을 인증하는데 string으로 사용하기 때문에 injection이 가능하다

